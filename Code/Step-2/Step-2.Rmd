---
title: "Step 2 - eQTM"
author: "Lisa Leung"
date: '2018-03-03'
output: github_document
---

#Loading Libraries
For Step 2, we will load three library packages: tidyverse, reshape, ggplot2. We will load the data sets built from Step 1: probes_subjects that contains DNA methylation probe values, subjects_genes that contains gene expression values, and probes_genes_distance that is a sparse matrix containing the distances between a gene and a probe. Note that probes_genes_distance is 0 when probe and gene distance is over 1Mb.

```{r}
library(tidyverse)
library(reshape)
library(ggplot2)
m <- load("~/STAT540/Repo_team_gene_heroes/rosmap_postprocV2.rdata")
probes_subjects[1:5,1:5] #look at what are these data sets
subjects_genes[1:5,1:5]

rownames(subjects_genes)==names(probes_subjects)

dat <- as.data.frame(as.matrix(probes_genes_distance))
dim(dat)
colnames(dat) <- names(subjects_genes)
rownames(dat) <- rownames(probes_subjects) #putting the genes and probes name back to the data frame
```

#Adjust PCs for gene expression data (labelled as m)

Here we are going to build gene expression data sets adjusted for various numbers of PCs. Although this data set is assumed not to have any batch effects (they are coming from one batch), we would like to adjust for gene expression data to account for hidden confounders that are not recorded in the study. Because we are unsure of how many PCs to adjust for, we would like to explore what happens to the results of correlation tests between gene and probe pair To run PCA, we will use svd() and adjust for 1, 5, 10, 15, 20, 25, 30 PCAs. The data set is saved as "subjects_genes_PCA_adjusted_V3.RDS"

```{r}
#SVD PCA
pc_svd <- svd(subjects_genes)

#exploring the dimensionality on PCA
length(pc_svd$d)
dim(pc_svd$u) #u is equivalent to the principal components
dim(pc_svd$v) 
plot(pc_svd$u[, 1], pc_svd$u[, 2], main = "SVD", xlab = "U1", ylab = "U2") #plot the first two PCs

# reconstructing the same values is shown below:
# SVD$u %*% diag(SVD$d) %*% t(SVD$v)

# Adjusting for the PCs according to number of PCA you want to adjust in gene expression data
m <- list()
n <- c(1,5,10,15,20, 25, 30)
for (i in n){
diag_of_d <- pc_svd$d
diag_of_d[1:i] <- 0
m[[i]] <- pc_svd$u %*% diag(diag_of_d) %*% t(pc_svd$v)
rownames(m[[i]]) <- rownames(subjects_genes)
colnames(m[[i]]) <- colnames(subjects_genes)
}

#saveRDS(m, "subjects_genes_PCA_adjusted_all.RDS")
```

#Adjust PCs for DNA methylation probe data (labelled as m2)

Below is adjusting for the DNA methylation probes. The reasons to adjust for DNA methylation probes are the same as why we decide to adjust for gene expression data (described above). Again, we will use svd() to adjust for 1, 5, 10, 15, 20, 25, 30 PCAs. The data set is saved as probes_subjects_PCA_adjusted_V3.RDS.

```{r}
#SVD PCA
pc_svd_probes <- svd(t(probes_subjects))

#exploring the dimensionality on PCA
length(pc_svd_probes$d)
dim(pc_svd_probes$u) #u is equivalent to the principal components
dim(pc_svd_probes$v) 
plot(pc_svd_probes$u[, 1], pc_svd$u[, 2], main = "SVD", xlab = "U1", ylab = "U2") #plot the first two PCs

# reconstructing the same values is shown below:
# SVD$u %*% diag(SVD$d) %*% t(SVD$v)

# Adjusting for the PCs according to number of PCA you want to adjust
m2 <- list()
for (i in n){
diag_of_d <- pc_svd_probes$d
diag_of_d[1:i] <- 0
m2[[i]] <- pc_svd_probes$u %*% diag(diag_of_d) %*% t(pc_svd_probes$v)
rownames(m2[[i]]) <- colnames(probes_subjects)
colnames(m2[[i]]) <- rownames(probes_subjects)
}

#saveRDS(m2, "probes_subjects_PCA_adjusted_all.RDS")
```

#Look at the number of significant results on 50 random genes

To look at what happens to the correlation test results on 49 different setting combination (7 different numbers of PCA adjusted for either gene expression data and DNA methylation probe data), we would like to see the nuber of significant results on 50 random genes. We believe that 50 can give us a rough estimate on what happens to these genes. This code will result plots with the number of PCs adjusted in either data set, and the proportion of genes that has at least one significant eQTM hit.

```{r}
set.seed(100)
n_genes <- sample(1:ncol(subjects_genes),50)

results_pca_50_genes = lapply(n, function(k){
out_per_gdata <-  lapply(n, function(l){
out_per_gene <-  lapply(n_genes, function(i){
    toLoop = which(dat[,i] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                 gene = colnames(subjects_genes)[i],
                estimate = cor.test(m[[k]][,i],
                                    m2[[l]][,j])$estimate,
                pvalue = cor.test(m[[k]][,i],
                                    m2[[l]][,j])$p.value)
      })
    gene_out <- do.call(rbind, out)
    gene_out$fdr <- p.adjust(gene_out$pvalue, method = "fdr")
    gene_out$bonferroni <- p.adjust(gene_out$pvalue, method = "bonferroni")
    data.frame(num_PC_gdata=k, gene = colnames(m[[k]])[i], num_less_fdr=sum(gene_out$fdr <= 0.1), num_less_bonferroni=sum(gene_out$bonferroni <= 0.1))
   # num_less_pvalue=sum(gene_out$pvalue <= 0.1))
}) 
do.call(rbind, out_per_gene) %>% mutate(num_PC_probedata = l)
})
do.call(rbind, out_per_gdata)
})

toPlot_50_genes_PCA_gdata_probedata <- do.call(rbind, results_pca_50_genes)
toPlot_50_genes_PCA_gdata_probedata$eqtl_fdr<-0
toPlot_50_genes_PCA_gdata_probedata$eqtl_fdr[toPlot_50_genes_PCA_gdata_probedata$num_less_fdr>0] <- 1
toPlot_50_genes_PCA_gdata_probedata$eqtl_bonferroni<-0
toPlot_50_genes_PCA_gdata_probedata$eqtl_bonferroni[toPlot_50_genes_PCA_gdata_probedata$num_less_bonferroni>0] <- 1

#saveRDS(toPlot_50_genes_PCA_gdata_probedata, "toPlot_50_genes_PCA_gdata_probedata_V4.RDS")

toPlot_50_genes_PCA_gdata_probedata_average <- toPlot_50_genes_PCA_gdata_probedata %>% group_by(num_PC_gdata, num_PC_probedata) %>% summarise(average_sig_fdr = mean(eqtl_fdr), average_sig_bonferroni = mean(eqtl_bonferroni))

toPlot_50_genes_PCA_gdata_probedata_average$num_PC_gdata <- as.factor(toPlot_50_genes_PCA_gdata_probedata_average$num_PC_gdata )
toPlot_50_genes_PCA_gdata_probedata_average$num_PC_probedata <- as.factor(toPlot_50_genes_PCA_gdata_probedata_average$num_PC_probedata )

jpeg("prop_of_genes_sig_on_50_genes_V4_fdr.jpg")
p <- ggplot(aes(x=num_PC_gdata, y = num_PC_probedata), data = toPlot_50_genes_PCA_gdata_probedata_average) + geom_tile(aes(fill=average_sig_fdr), color = "white") + scale_fill_gradient(low= "white", high = "steelblue", name = "Proportion of genes significant") 
p +  ggtitle("Proportion of genes with a significant eQTM for 50 genes") + xlab("Number of PCs Adjusted for Gene Expression Data") + ylab("Number of PCs Adjusted for DNA Methylation Data")
dev.off()

jpeg("prop_of_genes_sig_on_50_genes_V4_bonferroni.jpg")
p <- ggplot(aes(x=num_PC_gdata, y = num_PC_probedata), data = toPlot_50_genes_PCA_gdata_probedata_average) + geom_tile(aes(fill=average_sig_bonferroni), color = "white") + scale_fill_gradient(low= "white", high = "steelblue", name = "Proportion of genes significant") 
p +  ggtitle("Proportion of genes with a significant eQTM for 50 genes") + xlab("Number of PCs Adjusted for Gene Expression Data") + ylab("Number of PCs Adjusted for DNA Methylation Data")
dev.off()

```

Looks like adjusting for PCs in DNA methylation probes don't do much when very few PCAs are adjusted in the gene expression data, but changes when many PCs are adjusted in gene expression data. On the other hand, it is apparent that adjusting for PCAs in gene expression data does a lot - number of genes that contains at least one significant eQTM increases when PCAs adjusted increase. Based on the results, we will keep 5 PCs adjusted for DNA methylation and 30 PC adjusted for gene expression data. 

#Look at some random genes individually

We will plot the pvalues based on the number of adjusted PCs in the gene expression data set and observe what happens.

```{r}
#finding genes in data set
gene_name <- unique(sub(':.*$',"",colnames(subjects_genes)))
sum(gene_name %in% c("AKT2","APOBEC3B","APP"))
colnames(subjects_genes)[grep("AKT2",colnames(subjects_genes))]
colnames(subjects_genes)[grep("APP",colnames(subjects_genes))]

## using lapply looking at number of bonferroni = 0.05 based on number of PCA - recommended
#AKT2 on gene - Zohreh mentioned that this is a cnacer related gene
results_pca_AKT2 = lapply(n, function(i){
    toLoop = which(dat[,"AKT2:ENSG00000105221.10"] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                estimate = cor.test(m[[i]][,"AKT2:ENSG00000105221.10"],
                                    m2[[5]][,j])$estimate,
                pvalue = cor.test(m[[i]][,"AKT2:ENSG00000105221.10"], m2[[1]][,j])$p.value)
      })
   gene_out <-  do.call(rbind,out)
   gene_out$fdr <- p.adjust(gene_out$pvalue, method="fdr")
   data.frame(num_PC=i, num_less_pvalue=sum(gene_out$pvalue <= 0.1), num_less_fdr = sum(gene_out$fdr <= 0.1))
})

lapply_results_pca_AKT2 <- do.call(rbind,results_pca_AKT2)
ggplot(aes(x=num_PC, y=num_less_pvalue), data = lapply_results_pca_AKT2) + geom_point() + geom_line( ) + ggtitle("Number of DNA probes less than pvalue = 0.1 based on number of PCs for AKT2") + xlab("Number of PCs") + ylab("Number of significant DNA probes for alpha at 0.1")

#seems like there's nothing there, let's try another gene 

#APP on gene - Hiwot mentioned that this is related to Alzheimer's
results_pca_APP = lapply(n, function(i){
    toLoop = which(dat[,"APP:ENSG00000142192.14"] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                  estimate = cor.test(m[[i]][,"APP:ENSG00000142192.14"],
                                    m2[[5]][,j])$estimate,
                pvalue = cor.test(m[[i]][,"APP:ENSG00000142192.14"], m2[[5]][,j])$p.value)
      })
  gene_out <-  do.call(rbind,out)
   gene_out$fdr <- p.adjust(gene_out$pvalue, method="fdr")
   data.frame(num_PC=i, num_less_pvalue=sum(gene_out$pvalue <= 0.1), num_less_fdr = sum(gene_out$fdr <= 0.1))
})

lapply_results_pca_APP <- do.call(rbind,results_pca_APP)
ggplot(aes(x=num_PC, y=num_less_pvalue), data = lapply_results_pca_APP) + geom_point() + geom_line( ) + ggtitle("Number of DNA probes less than pvalue = 0.1 based on number of PCs for APP") + xlab("Number of PCs") + ylab("Number of significant DNA probes for alpha at 0.1")
```

Nothing much is going on in any of these genes, let's come back to this after we run the correlation test results on each pair of gene and probe.

#Cumulative variation explained by PCs

```{r}
#ref:http://genomicsclass.github.io/book/pages/pca_svd.html

#cum of first 50
jpeg("cum_var_explained_50_V4.jpg")
cumsum(pc_svd$d^2/sum(pc_svd$d^2))[1:50] #total variance seems to stabilize at 47th pc with 78% of variation explained
plot(cumsum(pc_svd$d^2/sum(pc_svd$d^2)), xlim = c(0, 50), type = "b", pch = 16, xlab = "principal components", 
     ylab = "cumulative variance explained")
dev.off()

```

#Correlation tests based on the PC adjusted data sets

This set of correlation test results will be passed on to Step 3. It contains all the statistics and significances for each pair of gene and probe. 

```{r}
## using lapply - recommended
PC_probes <- 5 # of PCs adjusted for probes data set
PC_genes <- 30 # of PCs adjusted for genes data set

results_PCA = lapply(1:ncol(m[[PC_genes]]), function(i){
    toLoop = which(dat[,i] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(gene = colnames(m[[PC_genes]])[i],
                probe = colnames(m2[[PC_probes]])[j], 
                estimate = cor.test(m[[PC_genes]][,i],m2[[PC_probes]][,j])$estimate,
                pvalue = cor.test(m[[PC_genes]][,i],m2[[PC_probes]][,j])$p.value)
      })
    do.call(rbind,out)
})

lapply_results_PCA <- do.call(rbind,results_PCA)
lapply_results_PCA$adjusted.pvalue <- p.adjust(lapply_results_PCA$pvalue, method="fdr") #adjusting for fdr
saveRDS(lapply_results_PCA,"cor_test_results_PCA_lapply_V4.rds")

jpeg("histogram_pvalue_V4.jpeg")
ggplot(aes(pvalue), data = lapply_results_PCA) + geom_histogram(bins=500) + ggtitle("Histogram of p-value on correlation tests")
dev.off()

summary(lapply_results_PCA$adjusted.pvalue)
min(lapply_results_PCA$adjusted.pvalue)

#saveRDS(t(m2[[5]]), "probes_subjects_PCA_adjusted_V4.RDS")
#saveRDS(m[[30]], "subjects_genes_PCA_adjusted_V4.RDS")
```

#Following up to looking at genes individually 

Because we haven't identified genes that gave multiple significant probes previously, we will do that now by looking at the correlation tests for all pairs below and take a look at which genes have multiple eQTMs

```{r}
filtered_cor_test_results <- lapply_results_PCA[lapply_results_PCA$adjusted.pvalue<=0.1,]
summary_cor_test_results <- filtered_cor_test_results %>% group_by(gene) %>% count()
summary_cor_test_results[order(-summary_cor_test_results$n),]

# Groups:   gene [610]
#   gene                             n
#   <fct>                        <int>
# 1 CYP2D6:ENSG00000100197.16       19
# 2 C21orf56:ENSG00000160284.10     18
# 3 NLRP2:ENSG00000022556.11        18
# 4 CSDC2:ENSG00000172346.9         17
# 5 L3MBTL1:ENSG00000185513.9       17
# 6 NKAIN4:ENSG00000101198.10       17
# 7 ELL:ENSG00000105656.5           16
# 8 AC016629.2:ENSG00000213753.4    16
# 9 POLR3H:ENSG00000100413.12       15
#10 C22orf32:ENSG00000183172.6      15

#CYP2D6:ENSG00000100197.16 - a gene that contains multiple significant probes 

results_pca_CYP2D6 = lapply(n, function(i){
    toLoop = which(dat[,"CYP2D6:ENSG00000100197.16"] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                estimate = cor.test(m[[i]][,"CYP2D6:ENSG00000100197.16"],
                                    m2[[5]][,j])$estimate,
                pvalue = cor.test(m[[i]][,"CYP2D6:ENSG00000100197.16"], m2[[5]][,j])$p.value)
      })
   gene_out <-  do.call(rbind,out)
   gene_out$fdr <- p.adjust(gene_out$pvalue, method="fdr")
   data.frame(num_PC=i, num_less_pvalue=sum(gene_out$pvalue <= 0.1), num_less_fdr = sum(gene_out$fdr <= 0.1))
})

lapply_results_pca_CYP2D6 <- do.call(rbind,results_pca_CYP2D6)
toPlot_lapply_results_pca_CYP2D6 <- lapply_results_pca_CYP2D6 %>% melt(id="num_PC")

jpeg("gene_CYP2D6.jpeg")
ggplot(aes(x=num_PC, y=value, colour=variable), data = toPlot_lapply_results_pca_CYP2D6) + geom_point() + geom_line( ) + ggtitle("Number of significant eQTMs by number of PCs for CYP2D6") + xlab("Number of PCs") + ylab("Number of significant DNA probes") + scale_colour_discrete(name = "P-value or FDR", breaks=c("num_less_pvalue", "num_less_fdr"), labels=c("P-value < 0.1", "FDR < 0.1"))
dev.off()

#C21orf56:ENSG00000160284.10 - a gene that contains multiple significant probes 

results_pca_C21orf56 = lapply(n, function(i){
    toLoop = which(dat[,"C21orf56:ENSG00000160284.10"] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                estimate = cor.test(m[[i]][,"C21orf56:ENSG00000160284.10"],
                                    m2[[5]][,j])$estimate,
                pvalue = cor.test(m[[i]][,"C21orf56:ENSG00000160284.10"], m2[[5]][,j])$p.value)
      })
   gene_out <-  do.call(rbind,out)
   gene_out$fdr <- p.adjust(gene_out$pvalue, method="fdr")
   data.frame(num_PC=i, num_less_pvalue=sum(gene_out$pvalue <= 0.1), num_less_fdr = sum(gene_out$fdr <= 0.1))
})

lapply_results_pca_C21orf56 <- do.call(rbind,results_pca_C21orf56)
toPlot_lapply_results_pca_C21orf56 <- lapply_results_pca_C21orf56 %>% melt(id="num_PC")

jpeg("gene_C21orf56.jpeg")
ggplot(aes(x=num_PC, y=value, colour=variable), data = toPlot_lapply_results_pca_C21orf56) + geom_point() + geom_line( ) + ggtitle("Number of significant eQTMs by number of PCs for C21orf56") + xlab("Number of PCs") + ylab("Number of significant DNA probes")+ scale_colour_discrete(name = "P-value or FDR", breaks=c("num_less_pvalue", "num_less_fdr"), labels=c("P-value < 0.1", "FDR < 0.1"))
dev.off()
```


