---
title: "Step 2 - eQTM"
author: "Lisa Leung"
date: '2018-03-03'
output: github_document
---

#Loading Libraries
For Step 2, we will load three library packages: tidyverse, reshape, ggplot2. We will load the data sets built from Step 1: probes_subjects that contains DNA methylation probe values, subjects_genes that contains gene expression values, and probes_genes_distance that is a sparse matrix containing the distances between a gene and a probe. Note that probes_genes_distance is 0 when probe and gene distance is over 1Mb.

```{r}
library(tidyverse)
library(reshape)
library(ggplot2)
m <- load("~/STAT540/Repo_team_Gene_Heroes/Code/Step-2/rosmap_postprocV2.rdata")
probes_subjects[1:5,1:5] #look at what are these data sets
subjects_genes[1:5,1:5]

rownames(subjects_genes)==names(probes_subjects)

dat <- as.data.frame(as.matrix(probes_genes_distance))
dim(dat)
colnames(dat) <- names(subjects_genes)
rownames(dat) <- rownames(probes_subjects) #putting the genes and probes name back to the data frame
```

#Adjust PCs for gene expression data (labelled as m)

Here we are going to build gene expression data sets adjusted for various numbers of PCs. Although this data set is assumed not to have any batch effects (they are coming from one batch), we would like to adjust for gene expression data to account for hidden confounders that are not recorded in the study. Because we are unsure of how many PCs to adjust for, we would like to explore what happens to the results of correlation tests between gene and probe pair To run PCA, we will use svd() and adjust for 1, 5, 10, 15, 20, 25, 30 PCAs. The data set is saved as "subjects_genes_PCA_adjusted_V3.RDS"

```{r}
#SVD PCA
pc_svd <- svd(subjects_genes)

#exploring the dimensionality on PCA
length(pc_svd$d)
dim(pc_svd$u) #u is equivalent to the principal components
dim(pc_svd$v) 
plot(pc_svd$u[, 1], pc_svd$u[, 2], main = "SVD", xlab = "U1", ylab = "U2") #plot the first two PCs

# reconstructing the same values is shown below:
# SVD$u %*% diag(SVD$d) %*% t(SVD$v)

# Adjusting for the PCs according to number of PCA you want to adjust in gene expression data
m <- list()
n <- c(1,5,10,15,20, 25, 30)
for (i in n){
diag_of_d <- pc_svd$d
diag_of_d[1:i] <- 0
m[[i]] <- pc_svd$u %*% diag(diag_of_d) %*% t(pc_svd$v)
rownames(m[[i]]) <- rownames(subjects_genes)
colnames(m[[i]]) <- colnames(subjects_genes)
}

saveRDS(m, "subjects_genes_PCA_adjusted_V3.RDS")
```

#Adjust PCs for DNA methylation probe data (labelled as m2)

Below is adjusting for the DNA methylation probes. The reasons to adjust for DNA methylation probes are the same as why we decide to adjust for gene expression data (described above). Again, we will use svd() to adjust for 1, 5, 10, 15, 20, 25, 30 PCAs. The data set is saved as probes_subjects_PCA_adjusted_V3.RDS.

```{r}
#SVD PCA
pc_svd_probes <- svd(t(probes_subjects))

#exploring the dimensionality on PCA
length(pc_svd_probes$d)
dim(pc_svd_probes$u) #u is equivalent to the principal components
dim(pc_svd_probes$v) 
plot(pc_svd_probes$u[, 1], pc_svd$u[, 2], main = "SVD", xlab = "U1", ylab = "U2") #plot the first two PCs

# reconstructing the same values is shown below:
# SVD$u %*% diag(SVD$d) %*% t(SVD$v)

# Adjusting for the PCs according to number of PCA you want to adjust
m2 <- list()
for (i in n){
diag_of_d <- pc_svd_probes$d
diag_of_d[1:i] <- 0
m2[[i]] <- pc_svd_probes$u %*% diag(diag_of_d) %*% t(pc_svd_probes$v)
rownames(m2[[i]]) <- colnames(probes_subjects)
colnames(m2[[i]]) <- rownames(probes_subjects)
}

saveRDS(m2, "probes_subjects_PCA_adjusted_V3.RDS")
```

#Look at the number of significant results on 50 random genes

To look at what happens to the correlation test results on 49 different setting combination (7 different numbers of PCA adjusted for either gene expression data and DNA methylation probe data), we would like to see the nuber of significant results on 50 random genes. We believe that 50 can give us a rough estimate on what happens to these genes. This code will result plots with the number of PCs adjusted in either data set, and the proportion of genes that has at least one significant eQTM hit.

```{r}
set.seed(100)
n_genes <- sample(1:ncol(subjects_genes),50)

results_pca_50_genes = lapply(n, function(k){
out_per_gdata <-  lapply(n, function(l){
out_per_gene <-  lapply(n_genes, function(i){
    toLoop = which(dat[,i] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                 gene = colnames(subjects_genes)[i],
                estimate = cor.test(m[[k]][,i],
                                    m2[[l]][,j])$estimate,
                pvalue = cor.test(m[[k]][,i],
                                    m2[[l]][,j])$p.value)
      })
    gene_out <- do.call(rbind, out)
    gene_out$bonferroni <- p.adjust(gene_out$pvalue, method = "bonferroni")
    data.frame(num_PC_gdata=k, gene = colnames(m[[k]])[i], num_less_pvalue=sum(gene_out$bonferroni <= 0.05))
   # num_less_pvalue=sum(gene_out$pvalue <= 0.1))
}) 
do.call(rbind, out_per_gene) %>% mutate(num_PC_probedata = l)
})
do.call(rbind, out_per_gdata)
})

toPlot_50_genes_PCA_gdata_probedata <- do.call(rbind, results_pca_50_genes)
toPlot_50_genes_PCA_gdata_probedata$eqtl<-0
toPlot_50_genes_PCA_gdata_probedata$eqtl[toPlot_50_genes_PCA_gdata_probedata$num_less_pvalue>0] <- 1
saveRDS(toPlot_50_genes_PCA_gdata_probedata, "toPlot_50_genes_PCA_gdata_probedata_V2.RDS")
toPlot_50_genes_PCA_gdata_probedata_average <- toPlot_50_genes_PCA_gdata_probedata %>% group_by(num_PC_gdata, num_PC_probedata) %>% summarise(average_sig = mean(eqtl))
toPlot_50_genes_PCA_gdata_probedata_average$num_PC_gdata <- as.factor(toPlot_50_genes_PCA_gdata_probedata_average$num_PC_gdata )
toPlot_50_genes_PCA_gdata_probedata_average$num_PC_probedata <- as.factor(toPlot_50_genes_PCA_gdata_probedata_average$num_PC_probedata )

jpeg("prop_of_genes_sig_on_50_genes_V3.jpg")
p <- ggplot(aes(x=num_PC_gdata, y = num_PC_probedata), data = toPlot_50_genes_PCA_gdata_probedata_average) + geom_tile(aes(fill=average_sig), color = "white") + scale_fill_gradient(low= "white", high = "steelblue", name = "Proportion of genes significant") 
p +  ggtitle("Proportion of genes with a significant eQTM for 50 genes") + xlab("Number of PCs Adjusted for Gene Expression Data") + ylab("Number of PCs Adjusted for DNA Methylation Data")
dev.off()

```

Looks like adjusting for PCAs in DNA methylation probes don't do much when few PCAs are adjusted in the gene expression data, but changes when many PCAs are adjusted in gene expression data. On the other hand, it is apparent that adjusting for PCAs in gene expression data does a lot - number of genes that contains at least one significant eQTM increases when PCAs adjusted increase. Based on the results, we will keep 1 PC adjusted for DNA methylation and 30 PC adjusted for gene expression data. 

#Look at some random genes individually

We will plot the pvalues based on the number of adjusted PCs in the gene expression data set and observe what happens.

```{r}
#finding genes in data set
gene_name <- unique(sub(':.*$',"",colnames(subjects_genes)))
sum(gene_name %in% c("AKT2","APOBEC3B","APP"))
colnames(subjects_genes)[grep("AKT2",colnames(subjects_genes))]
colnames(subjects_genes)[grep("APP",colnames(subjects_genes))]

## using lapply looking at number of bonferroni = 0.05 based on number of PCA - recommended
#AKT2 on gene - Zohreh mentioned that this is a cnacer related gene
results_pca_AKT2 = lapply(n, function(i){
    toLoop = which(dat[,"AKT2:ENSG00000105221.10"] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                estimate = cor.test(m[[i]][,"AKT2:ENSG00000105221.10"],
                                    m2[[1]][,j])$estimate,
                pvalue = cor.test(m[[i]][,"AKT2:ENSG00000105221.10"], m2[[1]][,j])$p.value)
      })
   gene_out <-  do.call(rbind,out)
   gene_out$fdr <- p.adjust(gene_out$pvalue, method="fdr")
   data.frame(num_PC=i, num_less_pvalue=sum(gene_out$pvalue <= 0.1), num_less_fdr = sum(gene_out$fdr <= 0.1))
})

lapply_results_pca_AKT2 <- do.call(rbind,results_pca_AKT2)
ggplot(aes(x=num_PC, y=num_less_pvalue), data = lapply_results_pca_AKT2) + geom_point() + geom_line( ) + ggtitle("Number of DNA probes less than pvalue = 0.1 based on number of PCs for AKT2") + xlab("Number of PCs") + ylab("Number of significant DNA probes for alpha at 0.1")

#seems like there's nothing there, let's try another gene 

#APP on gene - Hiwot mentioned that this is related to Alzheimer's
results_pca_APP = lapply(n, function(i){
    toLoop = which(dat[,"APP:ENSG00000142192.14"] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                  estimate = cor.test(m[[i]][,"APP:ENSG00000142192.14"],
                                    m2[[1]][,j])$estimate,
                pvalue = cor.test(m[[i]][,"APP:ENSG00000142192.14"], m2[[1]][,j])$p.value)
      })
  gene_out <-  do.call(rbind,out)
   gene_out$fdr <- p.adjust(gene_out$pvalue, method="fdr")
   data.frame(num_PC=i, num_less_pvalue=sum(gene_out$pvalue <= 0.1), num_less_fdr = sum(gene_out$fdr <= 0.1))
})

lapply_results_pca_APP <- do.call(rbind,results_pca_APP)
ggplot(aes(x=num_PC, y=num_less_pvalue), data = lapply_results_pca_APP) + geom_point() + geom_line( ) + ggtitle("Number of DNA probes less than pvalue = 0.1 based on number of PCs for APP") + xlab("Number of PCs") + ylab("Number of significant DNA probes for alpha at 0.1")
```

Nothing much is going on in any of these genes, let's come back to this after we run the correlation test results on each pair of gene and probe.

#Cumulative variation explained by PCs

```{r}
#ref:http://genomicsclass.github.io/book/pages/pca_svd.html

#cum of first 50
#first calculate the ratio of variance explained by each principal component
#and sum variances to find the cumulative variance explained by each additional PC
cum_var_explained_d<-(as.data.frame(cumsum(pc_svd$d^2/sum(pc_svd$d^2))))
cum_var_explained_d$pcs<-c(1:nrow(cum_var_explained_d))
colnames(cum_var_explained_d)<- c("cum_var_explained","PCs")
jpeg("cum_var_explained_50_V2.jpg")
ggplot(aes( x=PCs, y=cum_var_explained), data = cum_var_explained_d[1:50,]) + geom_point(size=1) + geom_line() + ggtitle("Cumulative variance explained by PCs") + xlab("Number of PCs") + ylab("Variance Explained")
dev.off()

```

#Correlation tests based on the PC adjusted data sets

This set of correlation test results will be passed on to Step 3. It contains all the statistics and significances for each pair of gene and probe. 

```{r}
## using lapply - recommended
PC_probes <- 1 # of PCs adjusted for probes data set
PC_genes <- 30 # of PCs adjusted for genes data set

results_PCA = lapply(1:ncol(m[[PC_genes]]), function(i){
    toLoop = which(dat[,i] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(gene = colnames(m[[PC_genes]])[i],
                probe = colnames(m2[[PC_probes]])[j], 
                estimate = cor.test(m[[PC_genes]][,i],m2[[PC_probes]][,j])$estimate,
                pvalue = cor.test(m[[PC_genes]][,i],m2[[PC_probes]][,j])$p.value)
      })
    do.call(rbind,out)
})

lapply_results_PCA <- do.call(rbind,results_PCA)
lapply_results_PCA$adjusted.pvalue <- p.adjust(lapply_results_PCA$pvalue, method="fdr") #adjusting for fdr
saveRDS(lapply_results_PCA,"cor_test_results_PCA_lapply_V3.rds")

jpeg("histogram_pvalue_V3.jpeg")
ggplot(aes(pvalue), data = lapply_results_PCA) + geom_histogram(bins=500) + ggtitle("Histogram of p-value on correlation tests")
dev.off()

summary(lapply_results_PCA$adjusted.pvalue)
min(lapply_results_PCA$adjusted.pvalue)

saveRDS(t(m2[[1]]), "probes_subjects_PCA_adjusted_V3.RDS")
saveRDS(m[[30]], "subjects_genes_PCA_adjusted_V3.RDS")
```

#Following up to looking at genes individually 



```{r}
ordered_cor_test_results <- lapply_results_PCA[order(lapply_results_PCA$adjusted.pvalue),]
ordered_cor_test_results[1:20,]

#                                     gene      probe   estimate       pvalue adjusted.pvalue
#cor1661318        FRG1B:ENSG00000149531.9 cg04945608 -0.7502561 4.059672e-88    5.421871e-82
#cor717719        NLRP2:ENSG00000022556.11 cg06679262 -0.7262288 5.483988e-80    3.662054e-74
#cor914085       ZNF714:ENSG00000160352.10 cg19716018 -0.7066983 5.429976e-74    2.417324e-68
#cor170065         FRG1B:ENSG00000149531.9 cg05256204 -0.7051708 1.523655e-73    5.087272e-68
#cor872626       SLC25A1:ENSG00000100075.5 cg05279387 -0.6835404 1.708119e-67    4.562536e-62
#cor2121327    C21orf56:ENSG00000160284.10 cg10215919 -0.6818413 4.847792e-67    1.079073e-61
#cor1491306    C21orf56:ENSG00000160284.10 cg04383274  0.6619444 5.886908e-62    1.123175e-56
#cor842887        NLRP2:ENSG00000022556.11 cg16580934  0.6551690 2.590970e-60    4.325442e-55
#cor580788       SLC25A1:ENSG00000100075.5 cg04121214 -0.6407521 5.933186e-57    8.804478e-52
#cor327748          MRI1:ENSG00000037757.9 cg01404753 -0.6170794 8.230820e-52    1.099262e-46
#cor731089         RRP7A:ENSG00000189306.6 cg03166514 -0.6075400 7.348182e-50    8.921654e-45
#cor584542          MRI1:ENSG00000037757.9 cg13699804 -0.6029851 5.950092e-49    6.622174e-44
#cor764651         VN1R1:ENSG00000178201.3 cg27285056  0.5962712 1.221835e-47    1.255242e-42
#cor843139        ZNF580:ENSG00000213015.4 cg00844791  0.5945945 2.570314e-47    2.451977e-42
#cor571387        NDUFA6:ENSG00000184983.4 cg19092981 -0.5932794 4.591942e-47    4.088494e-42
#cor1132571 RP4-564F22.2:ENSG00000196756.5 cg06269001  0.5907740 1.376809e-46    1.149243e-41
#cor651943        RWDD2B:ENSG00000156253.2 cg21231689 -0.5882080 4.197630e-46    3.297718e-41
#cor56815        CYP2D6:ENSG00000100197.16 cg07869308  0.5839219 2.642936e-45    1.960976e-40
#cor142944          YBEY:ENSG00000182362.9 cg05169244  0.5805809 1.088377e-44    7.650394e-40
#cor372291         RRP7A:ENSG00000189306.6 cg17961378  0.5753953 9.482605e-44    6.332218e-39

```

#Looking at individual genes
To look at what is actually going on 

```{r}
#C21orf56:ENSG00000160284.10 - a gene that contains multiple significant probes 

results_pca_APP = lapply(n, function(i){
    toLoop = which(dat[,"APP:ENSG00000142192.14"] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                estimate = cor.test(m[[i]][,"APP:ENSG00000142192.14"],
                                    as.numeric(t(probes_subjects[j,])))$estimate,
                pvalue = cor.test(m[[i]][,"APP:ENSG00000142192.14"], as.numeric(t(probes_subjects[j,])))$p.value)
      })
  gene_out <-  do.call(rbind,out)
   gene_out$fdr <- p.adjust(gene_out$pvalue, method="fdr")
   data.frame(num_PC=i, num_less_pvalue=sum(gene_out$pvalue <= 0.1), num_less_fdr = sum(gene_out$fdr <= 0.1))
})

lapply_results_pca_APP <- do.call(rbind,results_pca_APP)
ggplot(aes(x=num_PC, y=num_less_pvalue), data = lapply_results_pca_APP) + geom_point() + geom_line( ) + ggtitle("Number of DNA probes less than pvalue = 0.1 based on number of PCs for APP") + xlab("Number of PCs") + ylab("Number of significant DNA probes for alpha at 0.1")

```


