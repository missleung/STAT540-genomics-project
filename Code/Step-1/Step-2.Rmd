---
title: "Step 2"
author: "Lisa Leung"
date: '2018-03-03'
output: github_document
---
#Step 2 - eQTM

```{r}
library(tidyverse)
library(reshape)
library(ggplot2)
load("~/STAT540/STAT540/rosmap_postprocV1.rdata")
probes_subjects[1:5,1:5]
subjects_genes[1:5,1:5]

rownames(subjects_genes)==names(probes_subjects)
# cor.test(subjects_genes[,1],as.numeric(t(probes_subjects[1,])))$p.value

dat <- as.data.frame(as.matrix(probes_genes_distance))
dim(dat)
colnames(dat) <- names(subjects_genes)
rownames(dat) <- rownames(probes_subjects)

#SVD PCA
pc_svd <- svd(subjects_genes)

#exploring the dimensionality on PCA
length(pc_svd$d)
dim(pc_svd$u) #u is equivalent to the principal components
dim(pc_svd$v) 
plot(pc_svd$u[, 1], pc_svd$u[, 2], main = "SVD", xlab = "U1", ylab = "U2") #plot the first two PCs

# reconstructing the same values is shown below:
# SVD$u %*% diag(SVD$d) %*% t(SVD$v)

# Adjusting for the PCs according to number of PCA you want to adjust (right now it's first 5 pca)
m <- list()
n <- 20
for (i in 1:n){
diag_of_d <- pc_svd$d
diag_of_d[1:i] <- 0
m[[i]] <- pc_svd$u %*% diag(diag_of_d) %*% t(pc_svd$v)
rownames(m[[i]]) <- rownames(subjects_genes)
colnames(m[[i]]) <- colnames(subjects_genes)
}

#finding genes in data set
gene_name <- unique(sub(':.*$',"",colnames(subjects_genes)))
sum(gene_name %in% c("AKT2","APOBEC3B","APP"))
colnames(subjects_genes)[grep("AKT2",colnames(subjects_genes))]
colnames(subjects_genes)[grep("APP",colnames(subjects_genes))]

## using lapply looking at number of bonferroni = 0.05 based on number of PCA - recommended
#AKT2 on gene
results_pca_AKT2 = lapply(1:n, function(i){
    toLoop = which(dat[,"AKT2:ENSG00000105221.10"] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                estimate = cor.test(m[[i]][,"AKT2:ENSG00000105221.10"],
                                    as.numeric(t(probes_subjects[j,])))$estimate,
                pvalue = cor.test(m[[i]][,"AKT2:ENSG00000105221.10"], as.numeric(t(probes_subjects[j,])))$p.value)
      })
   gene_out <-  do.call(rbind,out)
   #gene_out$fdr <- p.adjust(gene_out$pvalue, method="fdr")
   data.frame(num_PC=i, num_less_pvalue=sum(gene_out$pvalue <= 0.1))
})

lapply_results_pca_AKT2 <- do.call(rbind,results_pca_AKT2)
ggplot(aes(x=num_PC, y=num_less_pvalue), data = lapply_results_pca_AKT2) + geom_point() + geom_line( ) + ggtitle("Number of DNA probes less than pvalue = 0.1 on number of PCs for AKT2") + xlab("Number of PCs") + ylab("Number of significant DNA probes for alpha at 0.1")

#APP on gene
results_pca_APP = lapply(1:n, function(i){
    toLoop = which(dat[,"APP:ENSG00000142192.14"] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                estimate = cor.test(m[[i]][,"APP:ENSG00000142192.14"],
                                    as.numeric(t(probes_subjects[j,])))$estimate,
                pvalue = cor.test(m[[i]][,"APP:ENSG00000142192.14"], as.numeric(t(probes_subjects[j,])))$p.value)
      })
   gene_out <-  do.call(rbind,out)
   #gene_out$fdr <- p.adjust(gene_out$pvalue, method="fdr")
   data.frame(num_PC=i, num_less_pvalue=sum(gene_out$pvalue <= 0.1))
})

lapply_results_pca_APP <- do.call(rbind,results_pca_APP)
plot(lapply_results_pca_APP$num_PC, lapply_results_pca_APP$num_less_pvalue)

#CCDC106 on gene
results_pca_CCDC106 = lapply(1:n, function(i){
    toLoop = which(dat[,"CCDC106:ENSG00000173581.3"] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                estimate = cor.test(m[[i]][,"CCDC106:ENSG00000173581.3"],
                                    as.numeric(t(probes_subjects[j,])))$estimate,
                pvalue = cor.test(m[[i]][,"CCDC106:ENSG00000173581.3"], as.numeric(t(probes_subjects[j,])))$p.value)
      })
   gene_out <-  do.call(rbind,out)
   #gene_out$fdr <- p.adjust(gene_out$pvalue, method="fdr")
   data.frame(num_PC=i, num_less_pvalue=sum(gene_out$pvalue <= 0.1))
})

lapply_results_pca_CCDC106 <- do.call(rbind,results_pca_CCDC106)
plot(lapply_results_pca_CCDC106$num_PC, lapply_results_pca_CCDC106$num_less_pvalue)


# look at random 10 genes
set.seed(100)
n_genes <- sample(1:ncol(subjects_genes),10)
results_pca_10_genes = parallel::mclapply(1:n, function(k){
out_genes = lapply(n_genes, function(i){
    toLoop = which(dat[,i] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                estimate = cor.test(m[[k]][,i],
                                    as.numeric(t(probes_subjects[j,])))$estimate,
                pvalue = cor.test(m[[k]][,i], as.numeric(t(probes_subjects[j,])))$p.value)
      })
    gene_out <- do.call(rbind,out)
    gene_out$bonferroni <- p.adjust(gene_out$pvalue, method = "bonferroni")
    data.frame(num_PC=k, gene = colnames(m[[k]])[i],    num_less_pvalue=sum(gene_out$bonferroni <= 0.05))
   # num_less_pvalue=sum(gene_out$pvalue <= 0.1))
})
do.call(rbind, out_genes)
}, mc.cores = 7)

#results_10_genes <- do.call(rbind, results_pca_10_genes)
results_10_genes_bonferroni_05 <- do.call(rbind, results_pca_10_genes)
#saveRDS(results_10_genes, "results_10_genes.RDS")
saveRDS(results_10_genes_bonferroni_05, "results_10_genes_bonferroni_05.RDS")

g1 <- ggplot(aes(x=num_PC, y=num_less_pvalue, group=gene, colour=gene), data = results_10_genes)
g1 + geom_point() + geom_line() + ggtitle("Number of DNA probes less than pvalue = 0.1 on number of PCs adjusted by gene") + xlab("Number of PCs") + ylab("Number of significant DNA probes for alpha at 0.1")

results_10_genes_average <- results_10_genes_bonferroni_05 %>% group_by(num_PC) %>% summarise(average_sig = mean(num_less_pvalue))
results_10_genes_average

p1 <- ggplot(aes(x=num_PC, y = average_sig), data=results_10_genes_average)
p1 + geom_line()+ ggtitle("Average number of DNA probes less than pvalue = 0.1 on number of PCs for 10 genes") + xlab("Number of PCs") + ylab("Number of significant DNA probes for alpha at 0.1")

# look at random 50 genes
set.seed(100)
n_genes <- sample(1:ncol(subjects_genes),50)
results_pca_50_genes = parallel::mclapply(1:n, function(k){
out_genes = lapply(n_genes, function(i){
    toLoop = which(dat[,i] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(probe = rownames(probes_subjects)[j], 
                estimate = cor.test(m[[k]][,i],
                                    as.numeric(t(probes_subjects[j,])))$estimate,
                pvalue = cor.test(m[[k]][,i], as.numeric(t(probes_subjects[j,])))$p.value)
      })
    gene_out <- do.call(rbind,out)
    gene_out$bonferroni <- p.adjust(gene_out$pvalue, method = "bonferroni")
    data.frame(num_PC=k, gene = colnames(m[[k]])[i],    num_less_pvalue=sum(gene_out$bonferroni <= 0.05))
   # num_less_pvalue=sum(gene_out$pvalue <= 0.1))
})
do.call(rbind, out_genes)
}, mc.cores = 7)

#results_50_genes <- do.call(rbind, results_pca_50_genes)
results_50_genes_bonerroni_05 <- do.call(rbind, results_pca_50_genes)
results_50_genes_bonerroni_05$eqtl<-0
results_50_genes_bonerroni_05$eqtl[results_50_genes_bonerroni_05$num_less_pvalue>0] <- 1
#saveRDS(results_50_genes, "results_50_genes.RDS")
saveRDS(results_50_genes_bonerroni_05, "results_50_genes_bonerroni_05.RDS")
results_50_genes_average <- results_50_genes_bonerroni_05 %>% group_by(num_PC) %>% summarise(average_sig = mean(eqtl))
results_50_genes_average


#p <- ggplot(aes(x=num_PC, y = average_sig), data=results_50_genes_average)
#p + geom_line( ) + ggtitle("Average number of DNA probes less than pvalue = 0.1 on #number of PCs for 50 genes") + xlab("Number of PCs") + ylab("Number of significant #DNA probes for alpha at 0.1")

p <- ggplot(aes(x=num_PC, y = average_sig), data=results_50_genes_average)
p + geom_line( ) + ggtitle("Proportion of genes with a significant eQTM for 50 genes") + xlab("Number of PCs") + ylab("Proportion of genes")


## using for loop - not recommended: below is for our own references 

#res <- data.frame()
#for (i in 1:ncol(subjects_genes)){
#  m <- data.frame()
#  toLoop = which(dat[,i] != 0) 
  
#  for (j in toLoop){
#    print(paste0(i," and ",j))
#    m <- rbind(m, data.frame(gene = names(subjects_genes)[i], probe = rownames(probes_subjects)[j], estimate = #cor.test(subjects_genes[,i], as.numeric(t(probes_subjects[j,])))$estimate,
#pvalue = cor.test(subjects_genes[,i], as.numeric(t(probes_subjects[j,])))$p.value))
#  }
#  res <- rbind(res, m)
#  rm(m)
#}

#saveRDS(res,"subset_of_results_new.rds")
#saveRDS(res[res$pvalue<0.05,], "subset_of_results_new_005.rds")
#summary(res$pvalue)

## using lapply - recommended
results = parallel::mclapply(1:ncol(subjects_genes), function(i){
    toLoop = which(dat[,i] != 0) 
    out <- lapply(toLoop, function(j){
      data.frame(gene = names(subjects_genes)[i],
                probe = rownames(probes_subjects)[j], 
                estimate = cor.test(subjects_genes[,i],
                                    as.numeric(t(probes_subjects[j,])))$estimate,
                pvalue = cor.test(subjects_genes[,i], as.numeric(t(probes_subjects[j,])))$p.value)
      })
    do.call(rbind,out)
}, mc.cores = 7)

lapply_results <- do.call(rbind,results)

lapply_results[1:4,]

saveRDS(lapply_results,"subset_of_results_lapply.rds")
```
